from cvprac.cvp_client import CvpClient
from cvprac.cvp_client_errors import CvpApiError
#Disables no certificate CVP warning
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
import json, re, csv
import argparse
from getpass import getpass

def updateInCVP(cvp, name, config, serial_number, apply=True):
    '''
    Args:
        name (str) -> name of the configlet
        config (str) -> content of configlet
        serial_number (str) -> device serial number
    Returns list of taskIds if any [1, 21]
    '''
    #Attempt to get config
    try:
        configlet_exists = cvp.api.get_configlet_by_name(name)
    except:
        # print ("Configlet {} doesn't exist".format(name))
        configlet_exists = None
    #get device information from CVP
    device_dict = cvp.api.get_device_by_serial_number(serial_number)

    #initialize tasks variable
    task_ids = []
    tasks = None
    
    #Configlet does not exist
    if configlet_exists is None:
        #add new configlet to CVP
        configlet = cvp.api.add_configlet(name, config)
        # print ("Added Configlet {} to CVP".format(name))
        #get newly created configlet
        new_configlet = cvp.api.get_configlet_by_name(name)

        if apply==True:
            #Create list of configlets to apply 
            configlets_to_apply = []
            #Add configlet to list of configlets to apply
            configlets_to_apply.append(new_configlet)

            #apply configlet to device
            tasks = cvp.api.apply_configlets_to_device("Generated by deployment script", device_dict,  configlets_to_apply)

    else:
        #configlet already exists

        #check if config is in sync
        # if checkIfDeviceInSync(device_dict) != True:
        #     #If device is not in sync return None
        #     return None

        #update existing configlet
        key = configlet_exists["key"]
        tasks = cvp.api.update_configlet(config, key, name, wait_task_ids=True)
        # print ("Modified Configlet {} in CVP".format(name))

        if apply == True:

            try:
                if "taskIds" in list(tasks):
                    # print "Returning tasks for configlet {}".format(name)
                    task_ids = tasks["taskIds"]
            except:
                pass

            updated_configlet = cvp.api.get_configlet_by_name(name)
            configlets_already_applied = cvp.api.get_configlets_by_netelement_id(device_dict["key"])["configletList"]
            names_of_configlets_already_applied = []
            for configlet in configlets_already_applied:
                names_of_configlets_already_applied.append(configlet["name"])

            if updated_configlet["name"] not in names_of_configlets_already_applied:
                # print "Configlet {} is not applied".format(updated_configlet["name"])
                # print "Applying {} to {}".format(updated_configlet["name"], device_dict["hostname"])
                tasks = cvp.api.apply_configlets_to_device("Generated by deployment script", device_dict,  [updated_configlet])
                # print ("Reapplied configlet to device")

    # return tasks
    if len(task_ids) > 0:
        try:
            tasks = tasks["data"]
            if "taskIds" in list(tasks):
                # print "Returning tasks for configlet {}".format(name)
                for task in tasks["taskIds"]:
                    if task not in task_ids:
                        task_ids.append(task)
                # print ("task_ids:", task_ids)
                return task_ids
            else:
                # print "No tasks to return for configlet {}".format(name)
                # print ("task_ids:", task_ids)
                return task_ids
        except:
            # print ("task_ids:", task_ids)
            return task_ids
    else:
        try:
            tasks = tasks["data"]
            if "taskIds" in list(tasks):
                # print "Returning tasks for configlet {}".format(name)
                # print ("task_ids:", task_ids)
                return tasks["taskIds"]
            else:
                # print "No tasks to return for configlet {}".format(name)
                # print ("task_ids:", task_ids)
                return []
        except:
            return []

def deploy_device_with_no_configlets(cvp, device_dict, target_container, image_bundle, include_container_configlets=False):
    '''
        Creates a static configlet of the reconcile config produced as if no configlets are applied to the device
        Then deploys device into proper container based off of first three characters of device hostname and applies previously generated configlet
    '''
    configlets_to_generate_reconcile = []
    configlets_to_apply = []
    if device_dict["streamingStatus"] == "inactive":
        print("{} - Device is not streaming data to CVP".format(device_dict["hostname"]))
        return
    #get device information from CVP
    print("{} - Getting device information...".format(device_dict["hostname"]))
    # print "Device"
    # print json.dumps(device_dict)
    # print "\n\n"
    device_id = device_dict["systemMacAddress"]
    
    # print "Configlets"
    # print json.dumps(configlets)
    # print "\n\n"

    print("{} - Got device information".format(device_dict["hostname"]))

    #keys of configlets we'll pretend are applied to a device when we generate a reconcile config
    if include_container_configlets == True:
        container_configlet_keys = [ configlet["key"] for configlet in cvp.api.get_configlets_inherited_from_containers(target_container) ]
    else:
        container_configlet_keys = []

    configlets_to_generate_reconcile = container_configlet_keys

    #Generate consolidated configlet
    print ("{} - Generating configlet configuration...".format(device_dict["hostname"]))
    validate_response = cvp.api.validate_configlets_for_device(device_id, configlets_to_generate_reconcile,
                                       page_type='validate')

    if "runningConfig" in validate_response.keys():
        config = []
        for line in validate_response["runningConfig"]:
            if include_container_configlets == True:
                if line["command"] == "!":
                    config.append(line["command"])
                elif line["shouldReconcile"] == True:
                    config.append(line["command"])
                else:
                    continue
            else:
                config.append(line["command"])

        # Parse out duplicate '!'s
        parsed_config = []
        for i, line in enumerate(config):
            if i != 0:
                if not(line == "!" and config[i-1] == "!"):
                    parsed_config.append(line)
        config = parsed_config

        config = "\n".join(config)
    else:
        print("{} - No reconcile configlet to generate.".format(device_dict["hostname"]))
        return

    #Create and apply consolidated configlet
    configlet_name = device_dict["hostname"]

    #Create New Configlet
    print ("{} - Updating/Creating configlet...".format(device_dict["hostname"]))
    tasks =  updateInCVP(cvp, configlet_name, config, device_dict["serialNumber"], apply=False)
    print ("{} - Updated/Created configlet".format(device_dict["hostname"]))

    try:
        configlet_to_apply = cvp.api.get_configlet_by_name(configlet_name)
    except CvpApiError as e:
        configlet_to_apply = None

    if configlet_to_apply is not None:
        configlets_to_apply.append(configlet_to_apply)
    else:
        print("{} - Could not find configlet named {}".format(configlet_name, device_dict["hostname"]))
        return

    if device_dict["parentContainerKey"] != "undefined_container":
        #Get already applied configlets at device level
        device_level_configlets = cvp.api.get_configlets_by_netelement_id(device_id)["configletList"]
        cvp.api.remove_configlets_from_device("Removed by script", device_dict, device_level_configlets)
        cvp.api.apply_configlets_to_device("Added by script", device_dict, configlets_to_apply)
    else:
        if target_container != "" and cvp.api.get_container_by_name(target_container) is None:
            print("{} - Could not find destination container for {}".format(device_dict["hostname"], device_dict["hostname"]))
            return
        
        if image_bundle != "" and cvp.api.get_image_bundle_by_name(image_bundle) is None:
            print("{} - Could not find image bundle for {}".format(device_dict["hostname"], device_dict["hostname"]))
            return
        cvp.api.deploy_device(device_dict, target_container, configlets=configlets_to_apply, image=image_bundle)
    return

def parseArgs():
    parser = argparse.ArgumentParser(
        description='Provisions devices in CVP')

    parser.add_argument('-u', '--user', help="Username for CVP user")
    parser.add_argument('-p', '--password', default=None, help="Password for CVP user")
    parser.add_argument('-host', '--cvp', help="CVP node IP Addresses separated by commas")
    parser.add_argument('-t', '--target', help="Name of device or container")
    parser.add_argument('-m', '--mode', default="extended",
    help="Options are: 'extended' and 'immediate'. If a container is provided to the target argument, the mode will determine whether to fetch the devices whose parent container is the target or all devices under the target")

    args = parser.parse_args()

    return args

def main():
    args = parseArgs()
    username = args.user
    password = args.password
    if password is None:
        print("Please provide a password for the user {}".format(username))
        password = getpass("Password:")
    cvp_addresses = [ address.strip() for address in  args.cvp.split(",") ]

    cvp = CvpClient()
    cvp.connect(cvp_addresses, username, password)

    #Define list of switches we will consolidate configlets
    switches = []

    #Check if target is a device
    container = None
    containers = cvp.api.get_containers()["data"]
    for c in containers:
        if c["name"] == args.target:
            container = c
            break
    
    #If no container is found from the target name, assume it is a device
    if container is not None:
        #Get devices in/under container
        if args.mode == "extended":
            switches = cvp.api.get_devices_under_container(args.target)
        else:
            switches = cvp.api.get_devices_in_container(args.target)
    
    else:
        inventory = cvp.api.get_inventory()
        for device in inventory:
            if device['hostname'] == args.target:
                switches.append(device)
                break

    for switch in switches:
        #Check to see if switch in spreadsheet and get VRF 
        try:
            switch_details = switch_info_dict[switch["hostname"]]
        except KeyError:
            print("Could not find {}'s serial number in spreadsheet".format(switch["hostname"]))
            continue
        deploy_device_with_no_configlets(cvp, switch, switch_details["Target Container"], switch_details["Image Bundle"], include_container_configlets=True)

if __name__ == "__main__":
    main()